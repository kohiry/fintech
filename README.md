# fintech


Моим ответом на очереди для каждого клиента будет такая комбинация:

- Corellation ID Pattern
- Шардирование

Я создаю шарды, каждый шард обрабатывает очередь, где загружено N количество
клиентов. Внутри очереди я обрабатываю каждого клиента как если бы это была личная 
очередь. 

При перегрузке определённого шарда я создаю резервный шард куда будут перенаправляться запросы в fanout exchenge
(теория на стадии планировния) и по маске сообщения распределяются в очереди. 

Так же стоит не забыть реализовать механизм очистку резервных шардов, при снижении нагрузки на шард. 

Так же должна быть реализована dead letter queue чтобы необработанные сообщения не терялись при падении системы. 

Так же в процессе изучения я ознакомился с подходом EDA, что возможно лучше данной реализации, но из-за её сложности 
(затраты времени на реализацию данного подхода, а так же простоты бизнес логики обработки транзакций), было принято решение
исполнять на чистом rabbit.

Схема микросервисов:
api gateway -> (регистрируется url webhook) + RPC -> client_transaction -> AMPQ -> runner -> RPC -> api_gateway -> webhook post -> client 

К сожалению, в идеале добавить graphana для мониторинга шардов, что позволит
более объективно реагировать на перегрузку, но я боюсь не хватит времени.


TO DO:
- [ ] api gateway
- [ ] jwt auth
- [ ] ouath
- [ ] user scheme
- [ ] ручки на транзакцию
- [ ] вебхук от клиента
- [ ] RPC коммуникация gateway и client_transaction
- [ ] шардирование
- [ ] создание очередей
- [ ] балансировка шардов (coming soon...)
- [ ] обработка сообщения раннером
- [ ] rpc ответ о завершении в gateway
- [ ] gateway post webhook
- [ ] client read this win/win!!
- [ ] логгирование (coming soon)
- [ ] тестирование (coming soon)
- 